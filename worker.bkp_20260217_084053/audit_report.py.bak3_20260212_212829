from __future__ import annotations

import csv
import json
from pathlib import Path
from typing import Dict, List, Any, Tuple
from datetime import datetime, timedelta

from engine.config import DATA_DIR

AUDIT_DIR = Path(DATA_DIR) / "audit"
OUT_SUMMARY = AUDIT_DIR / "report_summary.json"
OUT_BY_COIN = AUDIT_DIR / "report_by_coin.csv"


def _read_jsonl(path: Path) -> List[Dict[str, Any]]:
    if not path.exists():
        return []
    out: List[Dict[str, Any]] = []
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                out.append(json.loads(line))
            except Exception:
                continue
    return out


def _parse_ts(ts_brt: str) -> datetime:
    # ts_brt: "YYYY-MM-DD HH:MM"
    return datetime.strptime(ts_brt, "%Y-%m-%d %H:%M")


def _window_end(t0: datetime, minutes: int) -> datetime:
    return t0 + timedelta(minutes=minutes)


def _eval_signal(prices: List[Tuple[datetime, float]], *, side: str, entry: float, target: float,
                 t0: datetime, minutes: int) -> Dict[str, Any]:
    """
    prices: lista (ts, price) já filtrada por moeda e ordenada
    retorna: hit(bool), time_to_hit_min (ou None), adverse_pct (pior antes do hit, ou dentro da janela)
    """
    t1 = _window_end(t0, minutes)
    # pega pontos dentro da janela (inclui t0)
    pts = [(t, p) for (t, p) in prices if t0 <= t <= t1]
    if not pts:
        return {"hit": False, "time_to_hit_min": None, "adverse_pct": None}

    hit = False
    t_hit = None

    # adverso (pior movimento contra)
    min_p = min(p for _, p in pts)
    max_p = max(p for _, p in pts)

    if side == "LONG":
        # hit: algum preço >= target
        for t, p in pts:
            if p >= target:
                hit = True
                t_hit = t
                break
        # adverso: pior queda (min) em relação à entrada
        adverse = (min_p - entry) / entry * 100.0
    else:  # SHORT
        for t, p in pts:
            if p <= target:
                hit = True
                t_hit = t
                break
        # adverso: pior alta (max) contra a posição
        adverse = (entry - max_p) / entry * 100.0

    time_to_hit = None
    if hit and t_hit:
        time_to_hit = int(round((t_hit - t0).total_seconds() / 60.0))

        # recalcula adverso só até o hit (mais justo)
        pts2 = [(t, p) for (t, p) in pts if t <= t_hit]
        if pts2:
            min_p2 = min(p for _, p in pts2)
            max_p2 = max(p for _, p in pts2)
            if side == "LONG":
                adverse = (min_p2 - entry) / entry * 100.0
            else:
                adverse = (entry - max_p2) / entry * 100.0

    return {"hit": hit, "time_to_hit_min": time_to_hit, "adverse_pct": adverse}


def main():
    AUDIT_DIR.mkdir(parents=True, exist_ok=True)

    # lê todos os arquivos do audit dir
    prices_all: List[Dict[str, Any]] = []
    signals_all: List[Dict[str, Any]] = []

    for p in sorted(AUDIT_DIR.glob("prices_*.jsonl")):
        prices_all.extend(_read_jsonl(p))
    for p in sorted(AUDIT_DIR.glob("signals_*.jsonl")):
        signals_all.extend(_read_jsonl(p))

    # indexa preços por moeda
    prices_by_coin: Dict[str, List[Tuple[datetime, float]]] = {}
    for row in prices_all:
        par = str(row.get("par") or "").strip()
        ts = row.get("ts_brt")
        atual = row.get("atual")
        if not par or not ts:
            continue
        try:
            t = _parse_ts(str(ts))
            p = float(atual)
        except Exception:
            continue
        prices_by_coin.setdefault(par, []).append((t, p))

    for par in prices_by_coin:
        prices_by_coin[par].sort(key=lambda x: x[0])

    # janelas aprovadas
    WINDOWS = {
        "30m": 30,
        "1h": 60,
        "4h": 240,
        "24h": 1440,
    }

    # estatística por moeda
    stats: Dict[str, Dict[str, Any]] = {}

    for s in signals_all:
        par = str(s.get("par") or "").strip()
        side = str(s.get("side") or "").upper()
        ts = s.get("ts_brt")
        if not par or not ts or side not in ("LONG", "SHORT"):
            continue
        try:
            t0 = _parse_ts(str(ts))
            entry = float(s.get("atual") or 0.0)
            target = float(s.get("alvo") or 0.0)
            if entry <= 0 or target <= 0:
                continue
        except Exception:
            continue

        price_series = prices_by_coin.get(par, [])
        if not price_series:
            continue

        coin = stats.setdefault(par, {"signals": 0})
        coin["signals"] += 1

        # avalia cada janela
        for label, mins in WINDOWS.items():
            r = _eval_signal(price_series, side=side, entry=entry, target=target, t0=t0, minutes=mins)
            coin.setdefault(f"hit_{label}", 0)
            if r["hit"]:
                coin[f"hit_{label}"] += 1
                # tempo médio para hit (por janela)
                key_tt = f"tt_{label}_sum"
                coin[key_tt] = coin.get(key_tt, 0) + int(r["time_to_hit_min"] or 0)
                coin.setdefault(f"tt_{label}_count", 0)
                coin[f"tt_{label}_count"] += 1

            # adverso médio (por janela)
            adv = r["adverse_pct"]
            if adv is not None:
                key_as = f"adv_{label}_sum"
                coin[key_as] = coin.get(key_as, 0.0) + float(adv)
                coin.setdefault(f"adv_{label}_count", 0)
                coin[f"adv_{label}_count"] += 1

    # escreve CSV por moeda
    fields = [
        "par","signals",
        "hit_30m","hit_4h","hit_24h",
        "hit_rate_30m","hit_rate_4h","hit_rate_24h",
        "avg_time_to_hit_30m","avg_time_to_hit_4h","avg_time_to_hit_24h",
        "avg_adverse_30m","avg_adverse_4h","avg_adverse_24h",
    ]

    rows_out: List[Dict[str, Any]] = []
    total_signals = 0
    total_hits = {k:0 for k in WINDOWS.keys()}

    for par, st in sorted(stats.items()):
        n = int(st.get("signals", 0))
        if n <= 0:
            continue
        total_signals += n

        def hit(label):
            return int(st.get(f"hit_{label}", 0))

        h30, h4, h24 = hit("30m"), hit("4h"), hit("24h")
        for k in WINDOWS.keys():
            total_hits[k] += hit(k)

        def rate(h):
            return round((h / n) * 100.0, 2) if n else 0.0

        def avg_time(label):
            s = int(st.get(f"tt_{label}_sum", 0))
            c = int(st.get(f"tt_{label}_count", 0))
            return round(s / c, 1) if c else ""

        def avg_adv(label):
            s = float(st.get(f"adv_{label}_sum", 0.0))
            c = int(st.get(f"adv_{label}_count", 0))
            return round(s / c, 2) if c else ""

        rows_out.append({
            "par": par,
            "signals": n,
            "hit_30m": h30,
            "hit_4h": h4,
            "hit_24h": h24,
            "hit_rate_30m": rate(h30),
            "hit_rate_4h": rate(h4),
            "hit_rate_24h": rate(h24),
            "avg_time_to_hit_30m": avg_time("30m"),
            "avg_time_to_hit_4h": avg_time("4h"),
            "avg_time_to_hit_24h": avg_time("24h"),
            "avg_adverse_30m": avg_adv("30m"),
            "avg_adverse_4h": avg_adv("4h"),
            "avg_adverse_24h": avg_adv("24h"),
        })

    with OUT_BY_COIN.open("w", encoding="utf-8", newline="") as f:
        w = csv.DictWriter(f, fieldnames=fields)
        w.writeheader()
        for row in rows_out:
            w.writerow(row)

    summary = {
        "ok": True,
        "total_signals": total_signals,
        "hits": {k: total_hits[k] for k in WINDOWS.keys()},
        "hit_rate_pct": {k: (round((total_hits[k]/total_signals)*100.0, 2) if total_signals else 0.0) for k in WINDOWS.keys()},
        "files": {
            "by_coin_csv": str(OUT_BY_COIN),
            "summary_json": str(OUT_SUMMARY),
        }
    }

    with OUT_SUMMARY.open("w", encoding="utf-8") as f:
        json.dump(summary, f, ensure_ascii=False, indent=2)

    print("OK. Relatórios gerados em:", str(AUDIT_DIR))


if __name__ == "__main__":
    main()
